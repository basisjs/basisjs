## Basis.js

`basis.js` – javascript-фреймворк, ориентированный на разработку одностраничных приложений (`SPA`). Основной упор делается на динамику (все может меняться), гибкость, скорость и возможность работать с большим количеством данных.

Ключевыми направлениями являются:

* [данные](#Данные);
* [шаблоны](#Шаблоны);
* [пользовательский интерфейс](#ui).

### Данные

Выделяются три основные группы классов данных:

* [объекты](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.Object.md) (модели);
* [наборы](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.datasets.md) (коллекции);
* [скаляры](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.Value.md) (атомарные значения).

Модели делятся на простые и типизированные. Простые модели имеют базовую функциональность и могут иметь произвольный набор полей и значений.

```js
// простая модель
var simple = new basis.data.Object({
  data: {
    foo: 123,
    bar: 'example'
  }
});

simple.update({ bar: [1, 2, 3], baz: 'value' });
console.log(simple.data);
// console> { foo: 123, bar: [1, 2, 3], baz: 'value' }
```

Наиболее важная способность таких моделей — делегирование. Это механизм, при котором связанные объекты имеют общее состояние и ссылаются на одни и те же данные. Делегирование широко используется при построении интерфейса, так как узлы интерфейса являются потомками таких моделей и так же его поддерживают.

```js
// делегирование
var foo = new basis.data.Object({
  data: {
    a: 123
  }
});
var bar = new basis.data.Object({
  delegate: foo
});

console.log(bar.data.a);
// console> 123

foo.update({ a: 456 });
bar.update({ b: 'baz' });
console.log(bar.data);
// console> { a: 456, b: 'baz' }

console.log(bar.data === foo.data);
// console> true
```

Типизированные модели имеют более сложную реализацию. Они предоставляют дополнительные возможности: строгий набор полей, вычисляемые поля, нормализация значений, основной индекс (`primary key`, в том числе составной), обновления с возможностью отката и другое. Такие модели не умеют делегировать данные, но часто выступают в качестве источника данных.

```js
// типизированная модель
var SomeType = basis.entity.createType('SomeType', {
  id: basis.entity.IntId,
  name: String
});

var something = SomeType({ // оператор new не указывается, так как все зависит от того,
  id: 1,                   // есть ли экземпляр данного типа с id = 1 или нет; 
  name: 'example'          // если такого объекта нет, то он будет создает, а иначе обновлен
});                        // новыми данными
```

Объекты могут объединяться в наборы (множества). Наборы делятся на [обычные](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.datasets.md) и [автоматические](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.dataset.md). Состав обычных наборов задается через типовой для таких классов `API`. А состав автоматических наборов определяют наборы-источники и некоторое правило. Автоматические наборы можно воспринимать как операции над множествами. Так можно объединять, вычитать, получать подмножество, разбивать на группы, получать срез и так далее ([демонстрация работы разных наборов](http://basisjs.com/basisjs/demo/defile/dataset.html)).

```js
// обычный набор
var dataset = new basis.data.Dataset({
  items: [
    new basis.data.Object(..),
    new basis.data.Object(..)
  ]
});

// автоматический набор – содержит только объекты с нечетным значением
var odd = new basis.data.dataset.Filter({
  source: dataset,
  rule: function(item){
    return item.data.value % 2;
  }
});
```

[Скаляры](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.Value.md) хранят значения, которые воспринимаются как нечто неделимое. Они умеют связываться с другими объектами, преобразовывать значения, объединяться для получения нового значения и так далее.

```js
// значение
var atom = new basis.data.Value({
  value: 2
});

// преобразование
var cube = atom.as(function(value){
  return value * value * value;
});
console.log(cube.value);
// console> 8

atom.set(3);
console.log(cube.value);
// console> 27
```

К этой группе так же относятся индексы, агрегированные значения от множества. Они автоматически обновляют свое значение при изменении элементов набора или его состава.

```js
// набор
var dataset = new basis.data.Dataset({
  items: basis.data.wrap([1, 2, 3], true)
});

// индекс
var sum = basis.data.index.sum(dataset, function(item){
  return item.data.value;
});

console.log(sum.value);
// console> 6

dataset.remove(dataset.pick());

console.log(sum.value);
// console> 5
```

Все классы данных имеют состояние и некоторые другие [общие механизмы](https://github.com/basisjs/articles/blob/master/ru-RU/basis.data.md).

### Шаблоны

Большинство шаблонизаторов генерируют функцию, которая производит `HTML`, используя переданные ей данные. Далее `HTML` трансформируется в `DOM`-фрагмент через свойство `innerHTML`. При изменении данных процедура повторяется.

Шаблонизатор `basis.js` работает иначе. Он генерирует функцию, которая производит `DOM`-фрагмент и занимается дальнейшим его обслуживанием. Когда меняются данные, то в `DOM`-фрагменте производятся точечные изменения. Шаблонизатор работает только в терминах `DOM` и не имеет дело с `HTML`.

Шаблоны описываются в `HTML`-подобном формате. Описание размечается маркерами. В зависимости от положения в описании, маркеры являются либо местами для применения биндингов, либо ссылками на определенные `DOM`-узлы. Пример шаблона:

```html
<li{element} class="item item_{selected}">
  {title}
</li>
```

Для обработки событий на пользовательские действия используются атрибуты с префиксом `event-` ([подробнее](https://github.com/basisjs/articles/blob/master/ru-RU/basis.ui_actions.md)).

```html
<li{element} class="item item_{selected}" event-click="select">
  {title}
</li>
```

Шаблоны могут содержать специальные теги. Например, тег `<b:style>` позволяет подключать файлы стилей. Стили подключаются только когда начинает использоваться шаблон. Обычно каждый шаблон имеет собственный файл стилей.

```html
<b:style src="./item.css"/>
<li{element} class="item item_{selected}" event-click="select">
  {title}
</li>
```

Так же можно подключать другие шаблоны и модифицировать их.

```html
<b:style src="./item.css"/>
<li{element} class="item item_{selected}" event-click="select">
  {title}
  <b:include src="./button.tmpl">
    <b:set-attr name="event-click" value="remove"/>
    <b:replace ref="caption">
      Delete
    </b:replace>
  </b:include>
</li>
```

Описание шаблона может хранится в коде или во внешнем файле. В основном, шаблоны хранятся в отдельных файлах. Это позволяет их переиспользовать и производить различные оптимизации на этапе сборки. Непосредственно в коде текст шаблона указывается только на этапе прототипирования или для демонстраций.

Подробнее в документации – [Формат описания](https://github.com/basisjs/articles/blob/master/ru-RU/basis.template_format.md).

Подход используемый в `basis.js` позвляет работать с большим количеством представлений и гибко перестраивать интерфейс. Он так же позволяет обновлять описание шаблонов без перезагрузки страницы. Это используется при построении адаптивных интерфейсов, которые подстраиваются под объем данных, их структуру, размер экрана, форм-фактор и т.д.

Поддерживается [механизм тем](https://github.com/basisjs/articles/blob/master/ru-RU/basis.template_theme.md). Тема – это набор шаблонов. В один момент времени может использоваться только одна тема. Темы наследуются и их можно переключать без перезагрузки страницы.

```js
// базовая тема
basis.template.define({
  'button': resource('./button.tmpl'),
  'buttonPanel': resource('./buttonPanel.tmpl')
});

// дополнительная тема, все темы по умолчанию наследуются от базовой
basis.template.theme('mytheme').define({
  'button': resource('./mytheme/button.tmpl')
});

// вместо конкретного описания или указания файла, в качестве значения шаблона
// задается именовый шаблон; используемое описание будет зависеть от выбранной
// темы и какое описание закрепленное за этим именем в этой теме
var button = new basis.ui.Node({
  template: basis.template.get('button')
});

basis.template.setTheme('mytheme');
// button -> resource('./mytheme/button.tmpl')
// buttonPanel -> resource('./buttonPanel.tmpl')
```

Шаблоны поддерживают локализацию. Они могут как использовать языковые токены, переданные в качестве значения для биндингов, так и самостоятельно подключать словари. Для подключения словаря используется специальный тег `<b:l10n>`, а для вставки значений в описании биндинга используется префикс `l10n:`.

```html
<b:l10n src="./dict.l10n"/>
<div>
  <h1>{l10n:header}</h1>
  <div class="date">{day} {l10n:month.{month}} {year}</div>
  <div class="content">
    {l10n:content}
  </div>
</div>
```

Словари описываются в формате `.json`, но файлы должны иметь расширение `.l10n`. Пример словаря (`dict.l10n`):

```json
{
  "en-US": {
    "header": "Hello world!",
    "month": {
      "jan": "January",
      "feb": "February",
      ...
    }
  },
  "ru-RU": {
    "header": "Привет мир!",
    "month": {
      "jan": "Январь",
      "feb": "Февраль",
      ...
    }
  }
}
```

Шаблоны реагируют на изменение значений языковых токенов, и заменяют старые значения на новые в `DOM`. Благодаря этому поддерживается real-time редактирование локализации и переключение языка без перезагрузки страницы. Подробнее в документации модуля [basis.l10n](https://github.com/basisjs/articles/blob/master/ru-RU/basis.l10n.md).

Модули шаблонов и локализации могут быть использованы не только с `basis.js`, но и с другими библиотеками и фреймворками. Для этого можно использовать библиотеку [basis-templates](http://basisjs.com/templates/). Есть так же специальный [плагин](http://basisjs.com/templates/#bbt) для `backbone.js`.

Помимо [документации](https://github.com/basisjs/articles/blob/master/ru-RU/basis.template.md) про основы шаблонов можно посмотреть в презентациях «[Basis.js - почему я не бросил разрабатывать свой фреймворк](http://www.slideshare.net/basisjs/basisjs-fronttalks)» ([видео](http://www.youtube.com/watch?v=cVbbkwkhNQg)) и «[Как построить DOM](http://www.slideshare.net/basisjs/dom-27356908)».

### UI

В основе построения интерфейса лежит модель DOM, а сам интерфейс представляет собой одно большое дерево. Такой подход позволяет унифицировать API и использовать одни и те же паттерны для всех компонент.

```js
// hello world
var view = new basis.ui.Node({
  template: 'Hello world!'
});

// простой список
var list = new basis.ui.Node({
  template: '<ul>',
  childClass: {
    template: '<li>{name}</li>',
    binding: {
      name: 'name'
    }
  },
  childNodes: [
    { name: 'foo' },
    { name: 'bar' },
    { name: 'baz' }
  ]
});
```

Для наиболее частых задач есть готовые решения. Это позволяет просто создавать достаточно сложные представления. Большинство свойств представления можно изменить после его создания, используя соотвествующие методы.

```js
// выводим список компаний сгруппированных по городу и отсортированных
// по имени, с возможностью выбора элемента по клику
var companyView = new basis.ui.Node({
  dataSource: companies,          // набор, источник данных для дочерних узлов
  selection: true,                // использовать выделение
  sorting: 'data.name',           // сортировка по имени
  grouping: {                     // группировка
    rule: 'data.city',            // правило группировки
    childClass: {                 // класс для группы
      template:                   
        '<div class="group">' +   // обычно шаблоны выносятся в отдельные файлы,
          '{title}:' +            // здесь указаны в коде для наглядности
          '<ul{childNodesElement}/>'
        '</div>',
      binding: {
        title: 'data:id'
      }
    }
  },
  childClass: {                   // класс для дочерних узлов – дополненый basis.ui.Node
    template: '<li event-click="select">{name} (city)</li>',
    binding: {
      name: 'data:',
      city: 'data:'
    }
  }
});

// задать сортировку по стоимости по убыванию
companyView.setSorting('data.cost', true);

// убрать группировку
companyView.setGrouping(null);

// изменить источник данных
companyView.setDataSource(top100Companies);
```

## С чего начать

Рекомендуется начать с [руководства](https://github.com/basisjs/articles/blob/master/ru-RU/tutorial/index.md) (в процессе написания). Оно нацелено на постепенное погружение в фреймворк, от простого к сложному.

Основные ресурсы:

* Сайт [basisjs.com](http://basisjs.com)
* [Статьи](https://github.com/basisjs/articles) с подробным описанием фреймворка (в процессе написания);
* [Интерактивный тур](http://basisjs.com/tour) – набор слайдов, снабженных кодом, который можно менять;
* [Docs](http://basisjs.com/docs) – авто-документация, сгенерированная на основе структуры модулей и исходного кода;
* [Demo](http://basisjs.com/demo) – набор демонстраций, которые могут быть примером;
* [Слайды докладов](http://www.slideshare.net/basisjs) – слайды к выступлениям.

Новости и анонсы:

* [Блог](http://blog.basisjs.com/)
* [Twitter](http://twitter.com/basisjs)
* [Google+](https://plus.google.com/communities/102581433209953312275)

## Как использовать

Для подключения фреймворка в проект вы можете использовать `npm`:

    > npm install basisjs --save

Или установить через `bower`:
    
    > bower install basisjs --save

`basis.js` является модульным, в модулях указываются зависимости и от этого зависит, что попадет в сборку. По этой причине нет готовых пакетов.

В приложении подключается основной файл фреймворка (ядро). При этом у подключающего тега обязательно должен присутствовать атрибут `basis-config`, который так же может использоваться для задания настроек. Далее используются `basis.require()`, `basis.resource()` и `basis.asset()` для подключения модулей и других файлов.

```html
<script src="path/to/basisjs/src/basis.js" basis-config=""></script>
<script>
  basis.require('basis.ui');
  var view = new basis.ui.Node({
    template: basis.resource('./path/to/template.tmpl'),
    ...
  });
</script>
```

Более подробно в статье [Приступая к разработке](https://github.com/basisjs/articles/blob/master/ru-RU/get-started.md).

## Инструменты

Для автоматизации и более эффективной разработки рекомендуется использовать консольный инструмент [`basisjs-tools`](https://github.com/basisjs/basisjs-tools). Он предоставляет dev-сервер, обеспечивает сборку и помогает с генерацией кода.

[Плагин](https://chrome.google.com/webstore/detail/basisjs-tools/paeokpmlopbdaancddhdhmfepfhcbmek) для `Google Chrome` упрощает работу с локализацией, позволяет редактировать шаблоны, показывает проблемы приложения и граф его файлов.

Объединяющим оба инструмента является модуль `basis.devpanel`. Этот модуль предоставляет панель разработчика для быстрого переключения темы/языка, а так же выбора шаблона или текста для перевода.

## Вопросы и ответы

### Еще один фреймворк, зачем?

На самом деле фреймворку немало лет (около восьми), в течение которых он развивался как внутренний проект. Все это время мы ждали хорошей альтернативы, которая предоcтавила бы сопоставимые возможности, подходы и инструменты. Но этого так и не случилось.

В определенный момент фреймворк настолько увеличил эффективность разработки, что стало очевидно – он не может быть достоянием лишь одной компании. И он начал свой путь "в массы" и последний год готовился к открытому сообществу: "причесывался" код, организовывался процесс релизов, генерировался различный контент и т.д.

basis.js отличает то, что большинство его концепций уже устоялись и обкатаны, в отличие от молодых проектов. К тому же, это не только фреймворк, но и [инструменты](#%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B) для разработки. Он имеет собственные подходы и решения для различных задач. Эти подходы делают возможным реализацию многих функций, которые почти невозможны иначе. Например, динамическое обновление шаблонов и локализации без перезагрузки страницы, автоматический анализ и сборка проекта и другие. Так же у фреймворка [превосходная производительность](#%D0%9D%D0%B0%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B9-%D1%8D%D1%82%D0%BE%D1%82-%D0%B2%D0%B0%D1%88-%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D0%B2%D0%BE%D1%80%D0%BA), и он является одним из самых быстрых.

### Чем я могу помочь?

Способов помочь достаточно много. Наиболее простые из них:

- задайте свой вопрос – так будет понятней, с чем возникают сложности и о чем нужно писать в первую очередь;
- расскажите о фреймворке другим, напишите твит или сообщение на форуме – это поможет большему количеству людей узнать о нем;
- поддержите "лайками" основной репозиторий и [другие репозитории проекта](https://github.com/basisjs), а также публикации, которые вы встречаете о фреймворке – это поможет другим больше доверять проекту и более внимательно к нему присмотреться.

Проекту также очень нужны:

- бесстрашные ниндзя, готовые стать первопроходцами и поделиться своим опытом, чем помогут сделать фреймворк лучше и проще для начинающих;
- авторы, которые напишут статью;
- переводчики, которые могут помочь с переводом на английский;
- дизайнеры, готовые помочь с дизайном сайта и различных частей фреймворка: демонстрации, интерактивный тур, компоненты, etc.
- и многие другие.

### Я нашел баг, какие мои действия?

Заведите новый [issue](https://github.com/basisjs/basisjs/issues), опишите ситуацию, постараемся разобраться.

Если чувствуете в себе силы сами побороть баг, можете сделать Pull Request. Это же `open-source` ;) Только не забудьте приложить тест, подтверждающий, что проблема исправлена.

### Что я могу делать с фреймворком?

Если речь про его исходные коды, то все, что хотите, согласно лицензии `GPL` или `MIT`. Хотя это больше условность, так что просто руководствуйтесь здравым смыслом.

Если вопрос о возможностях фреймворка, то они достаточно широки. В нем есть все, что необходимо для создания больших и сложных одностраничных приложений. А если чего-то не хватает, напишите об этом – что-нибудь придумаем ;)

### Насколько быстрый этот ваш фреймворк?

Фреймворк рассчитан на приложения с большим количеством данных и представлений. Поэтому он достаточно быстрый и часто обгоняет другие фреймворки в тестах. Вот некоторые из них:

- тест от Jeremy Ashkenas (создатель Backbone) с анимацией: [его оригинальное исполнение](http://jsfiddle.net/rdvornov/L46HM/) и [реализация, считающая полное время кадра](http://jsfiddle.net/rdvornov/yE9Z9/)/
- [генерация простого списка, но с большим количеством элементов](http://plnkr.co/edit/RzZP7146NgWHlVchXZF7?p=preview)
- [генерация моделей](http://lahmatiy.github.io/lib-compare/) ([репозиторий](https://github.com/lahmatiy/lib-compare))

Без сравнения с другими:

- [генерация дерева](http://basisjs.com/basisjs/test/speed/tree.html)
- простой [блог с 5000 записей](http://basisjs.com/basisjs/demo/apps/blog/)

### Какие браузеры поддерживаются?

Начиная с версии `1.0`, поддерживается Internet Explorer, начиная c 8-й версии. Для остальных браузеров поддерживаются текущая и предыдущая версия.

### У меня есть вопросы – куда писать?

Если у вас вопрос, можете задать его в [Google groups](https://groups.google.com/forum/#!forum/basisjs) или в [сообществе на Google+](https://plus.google.com/communities/102581433209953312275).

Если вы нашли баг или у вас есть предложение по улучшению, лучше писать их в [Issues](https://github.com/basisjs/basisjs/issues).

По-прежнему не определились, куда написать, – пишите на `contact@basisjs.com`.
